"""
Auto-generate Sphinx rst pages for the "user guide" parts of the documentation.

Yes, this is the sort of thing that the Sphinx autodoc usually does.  But the
situation here is a bit off the beaten path, for example because we want to
show Clip-returing functions and Clip classes in the same way.

"""

import datetime
import glob
import inspect
import os
import re
import sys

MAIN_DIR = '_user'

HIDE_TAG = '|internal|'


sys.path.insert(0, os.path.join(os.path.split(__file__)[0], '..'))
import clip

os.chdir(os.path.split(__file__)[0])
os.makedirs(MAIN_DIR, exist_ok=True)

def is_public(thing, sig):
    # Determine whether a thing should be in the "public" API documentation
    # ---a Clip class or a function that returns a clip, and lacking a "hide"
    # attribute.
    if HIDE_TAG in doc:
        return False
    elif inspect.isclass(thing):
        return issubclass(thing, clip.Clip)
    else:
        return callable(thing) and sig.return_annotation is clip.Clip

created_files = set()

print('Creating user guide pages for...')
for name, thing in clip.__dict__.items():
    doc = thing.__doc__ if thing.__doc__ else ''

    try:
        sig = inspect.signature(thing)
    except (TypeError, ValueError):
        sig = None

    if is_public(thing, sig):
        params = ', '.join([ str(x) for x in sig.parameters.values() ])
        print(f'  {name}({params})')
        basename = f'{name}.rst'
        filename = os.path.join(MAIN_DIR, basename)
        with open(filename, 'w') as f:
            print(f'..', file=f)
            print(f'    I was generated by {__file__} on {datetime.datetime.now()}.', file=f)
            print(f"    You probably don't want to modify me directly.", file=f)
            print(file=f)
            print('='*len(name), file=f)
            print(name, file=f)
            print('='*len(name), file=f)
            print(file=f)
            print(f'.. py:function:: {name}({params})\n', file=f)
            print(f'    ' + doc.replace(HIDE_TAG, '').strip(), file=f)
        created_files.add(basename)

for basename in os.listdir(MAIN_DIR):
    if basename not in created_files:
        print("  deleting ", basename)
        os.remove(os.path.join(MAIN_DIR, basename))

