
class Align(Enum):
    """ When stacking clips, how should each be placed? """
    CENTER = 1
    LEFT = 2
    TOP = 3
    START = 4
    RIGHT = 5
    BOTTOM = 6
    END = 7

def stack_clips(*args, align, min_dim=0, vert, name):
    """ Arrange a series of clips in a stack, either vertically or
    horizontally.  Probably use vstack or hstack to call this. """

    # Flatten things out, in case the inputs were wrapped in a list.
    clips = flatten_args(args)

    # Compute the width or height.  Do this first so we can maybe center things
    # below.
    dim = min_dim
    for clip in clips:
        if isinstance(clip, Clip):
            clip_dim = clip.width() if vert else clip.height()
            dim = max(dim, clip_dim)
        elif is_int(clip):
            pass
        else:
            raise TypeError(f"In {name}, got a {type(clip)} instead of Clip or int.")

    # Sanity check the alignment.
    if vert:
        valid_aligns = [Align.LEFT, Align.RIGHT, Align.CENTER]
    else:
        valid_aligns = [Align.TOP, Align.BOTTOM, Align.CENTER]

    if align not in valid_aligns:
        raise NotImplementedError(f"Don't know how to align {align} in {name}.")


    # Place each clip in the composite in the correct place.

    a = 0  # The coordinate that we compute each time based on align.
    b = 0  # The coordinate that moves steady forward.

    elements = []

    for clip in clips:
        if isinstance(clip, Clip):
            clip_dim = clip.width() if vert else clip.height()

            if align in [Align.LEFT, Align.TOP]:
                a = 0
            elif align==Align.CENTER:
                a = int((dim - clip_dim)/2)
            else: # align in [Align.RIGHT, Align.BOTTOM]
                a = dim - clip_dim

            elements.append(Element(clip=clip,
                                    start_time=0,
                                    position=[a, b] if vert else [b, a]))

            b += clip.height() if vert else clip.width()
        else: # must be an int, as checked above
            b += clip

    if vert:
        return composite(elements, width=dim, height=b)
    else:
        return composite(elements, height=dim, width=b)

def vstack(*args, align=Align.CENTER, min_width=0):
    """ Arrange a series of clips in a vertical stack. """
    return stack_clips(args, align=align, min_dim=min_width, vert=True, name='vstack')

def hstack(*args, align=Align.CENTER, min_height=0):
    """ Arrange a series of clips in a horizontal row. """
    return stack_clips(args, align=align, min_dim=min_height, vert=False, name='hstack')

def background(clip, bg_color):
    """ Blend a clip onto a same-sized background of the given color. """
    require_clip(clip, 'clip')
    require_color(bg_color, 'background color')

    return composite(Element(solid(bg_color,
                                   clip.width(),
                                   clip.height(),
                                   clip.frame_rate(),
                                   clip.length()),
                             0,
                             (0,0)),
                      Element(clip,
                              0,
                              (0,0),
                              video_mode=VideoMode.BLEND))


def superimpose_center(under_clip, over_clip, start_time, audio_mode=AudioMode.ADD):
    """Superimpose one clip on another, in the center of each frame, starting at
    a given time."""
    require_clip(under_clip, "under clip")
    require_clip(over_clip, "over clip")
    require_float(start_time, "start time")
    require_non_negative(start_time, "start time")

    x = int(under_clip.width()/2) - int(over_clip.width()/2)
    y = int(under_clip.height()/2) - int(over_clip.height()/2)

    return composite(Element(under_clip, 0, [0,0], VideoMode.REPLACE),
                     Element(over_clip, start_time, [x,y], VideoMode.REPLACE, audio_mode))

def loop(clip, length):
    """Repeat a clip as needed to fill the given length."""
    require_clip(clip, "clip")
    require_float(length, "length")
    require_positive(length, "length")

    full_plays = int(length/clip.length())
    partial_play = length - full_plays*clip.length()
    return chain(full_plays*[clip], slice_clip(clip, 0, partial_play))

class ken_burns(MutatorClip):
    """Pan and/or zoom through a clip over time."""
    def __init__(self, clip, width, height, start_top_left, start_bottom_right,
                 end_top_left, end_bottom_right):
        super().__init__(clip)

        # So. Many. Ways to mess up.
        require_int_point(start_top_left, "start top left")
        require_int_point(start_bottom_right, "start bottom right")
        require_int_point(end_top_left, "end top left")
        require_int_point(end_bottom_right, "end bottom right")
        require_non_negative(start_top_left[0], "start top left x")
        require_non_negative(start_top_left[1], "start top left y")
        require_non_negative(end_top_left[0], "end top left x")
        require_non_negative(end_top_left[1], "end top left y")
        require_less(start_top_left[0], start_bottom_right[0],
                     "start top left x", "start bottom right x")
        require_less(start_top_left[1], start_bottom_right[1],
                     "start top left y", "start bottom right y")
        require_less(end_top_left[0], end_bottom_right[0],
                     "end top left x", "end bottom right x")
        require_less(end_top_left[1], end_bottom_right[1],
                     "end top left y", "end bottom right y")
        require_less_equal(start_bottom_right[0], clip.width(),
                           "start bottom right x", "clip width")
        require_less_equal(start_bottom_right[1], clip.height(),
                           "start bottom right y", "clip height")
        require_less_equal(end_bottom_right[0], clip.width(),
                           "end bottom right x", "clip width")
        require_less_equal(end_bottom_right[1], clip.height(),
                           "end bottom right y", "clip height")


        start_ratio = ((start_bottom_right[0] - start_top_left[0])
                       / (start_bottom_right[1] - start_top_left[1]))

        end_ratio = ((end_bottom_right[0] - end_top_left[0])
                     / (end_bottom_right[1] - end_top_left[1]))

        output_ratio = width/height

        if not math.isclose(start_ratio, output_ratio, abs_tol=0.01):
            raise ValueError("This ken_burns effect will distort the image at the start. "
                             f'Starting aspect ratio is {start_ratio}. '
                             f'Output aspect ratio is {output_ratio}. ')

        if not math.isclose(end_ratio, output_ratio, abs_tol=0.01):
            raise ValueError("This ken_burns effect will distort the image at the end. "
                             f'Ending aspect ratio is {end_ratio}. '
                             f'Output aspect ratio is {output_ratio}. ')

        self.start_top_left = np.array(start_top_left)
        self.start_bottom_right = np.array(start_bottom_right)
        self.end_top_left = np.array(end_top_left)
        self.end_bottom_right = np.array(end_bottom_right)

        self.metrics = Metrics(src=clip.metrics,
                               width=width,
                               height=height)

    def get_corners(self, index):
        """ Return the top left and bottom right corners of the view at the
        given frame index. """
        alpha = index/self.clip.num_frames()
        p1 = (((1-alpha)*self.start_top_left + alpha*self.end_top_left))
        p2 = (((1-alpha)*self.start_bottom_right + alpha*self.end_bottom_right))
        p1 = np.around(p1).astype(int)
        p2 = np.around(p2).astype(int)
        return p1, p2

    def frame_signature(self, index):
        p1, p2 = self.get_corners(index)
        return ['ken_burns', {'top_left': p1,
                              'bottom_right': p2,
                              'frame':self.clip.frame_signature(index)}]

    def get_frame(self, index):
        p1, p2 = self.get_corners(index)
        frame = self.clip.get_frame(index)
        fragment = frame[p1[1]:p2[1],p1[0]:p2[0],:]
        sized_fragment = cv2.resize(fragment, (self.width(), self.height()))
        return sized_fragment


def fade_between(clip1, clip2):
    """ Fade from one clip to another.  Both must have the same length. """
    require_clip(clip1, "first clip")
    require_clip(clip2, "second clip")
    require_equal(clip1.length(), clip2.length(), "clip lengths")

    return chain(clip1, clip2, fade_time=clip1.length())

class silence_audio(MutatorClip):
    """ Replace whatever audio we have with silence. """
    def get_samples(self):
        return np.zeros([self.metrics.num_samples(), self.metrics.num_channels])

