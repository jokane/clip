if sys.version_info.major == 3 and sys.version_info.minor < 8:
    Label = collections.namedtuple('Label', ['text', 'color', 'font', 'size', 'x', 'y', 'start', 'end'])
else:
    Label = collections.namedtuple('Label', ['text', 'color', 'font', 'size', 'x', 'y', 'start', 'end'], defaults=[None]*4)

def add_titles(clip, labels, x=None, y=None, halign="center", valign="center", lalign="center", spacing=1.2):
    """
    Add several labels, with the locations computed to stack nicely. The
    labels parameter should be an iterable of Labels, whose positions are
    ignored.
    """

    # If we just got one label, pretend it was a list.
    if isinstance(labels, Label):
        labels = [labels]

    # Make a dummy frame, so we can compute text sizes.
    pil_image = Image.new("RGB", (clip.width(), clip.height()))
    draw = ImageDraw.Draw(pil_image)

    # Figure out how big the rectangle containing the titles needs to be.
    width = 0
    height = 0
    for label in labels:
        font = get_font(label.font, label.size)
        size = draw.textsize(label.text, font=font)
        width = max(width, size[0])
        height += int(spacing * size[1])

    # If we didn't get an x or y position, use the center of the frame.
    if x is None:
        x = int(clip.width()/2)
    if y is None:
        y = int(clip.height()/2)

    # Figure out where the top left corner of the box should be placed.
    if halign == 'left':
        left = x
    elif halign == 'right':
        left = x - width
    elif halign == 'center':
        left = x - int(width/2)
    else:
        raise Exception(f'Unknown halign {halign}.')

    if valign == 'top':
        top = y
    elif valign == 'bottom':
        top = y - height
    elif valign == 'center':
        top = y - int(height/2)
    else:
        raise Exception(f'Unknown valign {valign}.')

    # Create labels positioned correctly within that box.
    new_labels = list()
    y = top
    for label in labels:
        font = get_font(label.font, label.size)
        size = draw.textsize(label.text, font=font)

        if lalign == 'left':
            x = left
        elif lalign == 'right':
            x = left + width - size[0]
        elif lalign == 'center':
            x = left + int((width - size[0])/2)
        else:
            raise Exception(f'Unknown lalign {lalign}.')

        new_label = label._replace(x=x, y=y)
        new_labels.append(new_label)
        y += int(spacing * size[1])

    # Return an add_labels that uses these correctly-positioned new labels.
    return add_labels(clip, new_labels)


def superimpose_center(under_clip, over_clip, start_frame, audio='ignore'):
    """Superimpose one clip on another, in the center of each frame, starting at
    a given time."""
    assert isinstance(under_clip, Clip)
    assert isinstance(over_clip, Clip)
    assert isinstance(start_frame, int)
    x = int(under_clip.width()/2) - int(over_clip.width()/2)
    y = int(under_clip.height()/2) - int(over_clip.height()/2)
    return superimpose(under_clip, over_clip, x, y, start_frame, audio)

def loop(clip, length):
    "Repeat a clip as needed to fill the given length."
    assert isinstance(clip, Clip)
    assert isinstance(length, int)
    assert length > 0
    full_plays = int(length/clip.length())
    partial_play = length - full_plays*clip.length()
    return chain(full_plays*[clip], slice_video(clip, 0, partial_play))

class horizontal_scroll(Clip):
    def __init__(self, clip, frame_index, width):
        assert isinstance(clip, Clip) 
        assert isinstance(frame_index, int)
        assert isinstance(width, int)

        self.clip = clip
        self.frame_index = frame_index
        self.width_ = width

        self.source_frame = clip.get_frame(frame_index)

    def __repr__(self):
        return f'horizontal_scroll({self.clip}, {self.frame_index}, {self.width_})'

    def frame_rate(self):
        return self.clip.frame_rate()

    def length(self):
        return self.source_frame.shape[1] - self.width_

    def width(self):
        return self.width_

    def height(self):
        return self.source_frame.shape[0]

    def frame_signature(self, index):
        return f"%s hs:%s/%s" % (self.clip.frame_signature(self.frame_index), self.width_, index)

    def get_frame(self, index):
        x = self.source_frame[:,index:index+self.width_,:]
        return x

    def get_audio(self):
        return self.clip.get_audio()

class ken_burns(Clip):
    def __init__(self, clip, width, height, start_top_left, start_bottom_right, end_top_left, end_bottom_right):
        self.clip = clip
        self.width_ = width
        self.height_ = height
        self.start_top_left = np.array(start_top_left)
        self.start_bottom_right = np.array(start_bottom_right)
        self.end_top_left = np.array(end_top_left)
        self.end_bottom_right = np.array(end_bottom_right)

    def __repr__(self):
        return f'ken_burns({self.clip}, {self.width_}, {self.height_}, {self.start_top_left}, {self.start_bottom_right}, {self.end_top_left}, {self.end_bottom_right})'

    def frame_rate(self):
        return self.clip.frame_rate()

    def frame_signature(self, index):
        return f'{self.__repr__()}:f{index}'

    def get_audio(self):
        return self.clip.get_audio()
    
    def height(self):
        return self.height_

    def width(self):
        return self.width_

    def length(self):
        return self.clip.length()

    def get_frame(self, index):
        alpha = index/self.clip.length()
        frame = self.clip.get_frame(index)
        p1 = (((1-alpha)*self.start_top_left + alpha*self.end_top_left)).astype(int)
        p2 = (((1-alpha)*self.start_bottom_right + alpha*self.end_bottom_right)).astype(int)
        fragment = frame[p1[1]:p2[1],p1[0]:p2[0],:]
        sized_fragment = cv2.resize(fragment, (self.width_, self.height_))
        #print(f"ken_burns: index={index} alpha={alpha} p1={p1} p2={p2} fragment.shape={fragment.shape} sized_fragment.shape={sized_fragment.shape}")
        return sized_fragment



def pdf_scroll(pdf, length, **kwargs):
    width=500
    height=300
        
    cached_filename, success = cache.lookup(f'pdf composite {pdf}', 'png')
    if not success:
        print(f"Building composite image of {pdf}...")
        page_images = pdf2image.convert_from_path(pdf, **kwargs)
        page_images = list(map(lambda x: np.array(x), page_images))

        big_image = np.vstack(page_images)
        cv2.imwrite(cached_filename, big_image)
        cache.insert(cached_filename)
    else:
        print(f"Using cached composite image of {pdf}")
        big_image = cv2.imread(cached_filename)
        

    vid = static_frame(pdf, big_image, frame_rate, length)
    vid = ken_burns(vid,
        width=width,
        height=height,
        start_top_left=(0,0),
        start_bottom_right=(vid.width(), (height/width)*vid.width()),
        end_top_left=(0,vid.height()-(height/width)*vid.width()),
        end_bottom_right=(vid.width(), vid.height())
    )
    
    return vid
