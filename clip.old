

class spin(MutatorClip):
    """ Rotate the contents of a clip about the center, a given number of
    times. Rotational velocity is computed to complete the requested rotations
    within the length of the original clip."""
    def __init__(self, clip, total_rotations):
        super().__init__(clip)

        require_float(total_rotations, "total rotations")
        require_non_negative(total_rotations, "total rotations")

        # Leave enough space to show the full undrlying clip at every
        # orientation.
        self.radius = math.ceil(math.sqrt(clip.width()**2 + clip.height()**2))

        self.metrics = Metrics(src=clip.metrics,
                               width=self.radius,
                               height=self.radius)

        # Figure out how much to rotate in each frame.
        rotations_per_second = total_rotations / clip.length()
        rotations_per_frame = rotations_per_second / clip.frame_rate()
        self.degrees_per_frame = 360 * rotations_per_frame

    def frame_signature(self, index):
        assert index < self.num_frames()
        sig = self.clip.frame_signature(index)
        degrees = self.degrees_per_frame * index
        return [f'rotated by {degrees}', sig]

    def get_frame(self, index):
        frame = np.zeros([self.radius, self.radius, 4], np.uint8)
        original_frame = self.clip.get_frame(index)

        a = (frame.shape[0] - original_frame.shape[0])
        b = (frame.shape[1] - original_frame.shape[1])

        frame[
            int(a/2):int(a/2)+original_frame.shape[0],
            int(b/2):int(b/2)+original_frame.shape[1],
            :
        ] = original_frame

        degrees = self.degrees_per_frame * index

        # https://stackoverflow.com/questions/9041681/opencv-python-rotate-image-by-x-degrees-around-specific-point
        image_center = tuple(np.array(frame.shape[1::-1]) / 2)
        rot_mat = cv2.getRotationMatrix2D(image_center, degrees, 1.0)
        rotated_frame = cv2.warpAffine(frame,
                                       rot_mat,
                                       frame.shape[1::-1],
                                       flags=cv2.INTER_NEAREST,
                                       borderMode=cv2.BORDER_CONSTANT,
                                       borderValue=[0,0,0,0])
        # Using INTER_NEAREST here instead of INTER_LINEAR has two effects:
        # 1. It prevents an artifical "border" from appearing when INTER_LINEAR
        # blends "real" pixels with the background zeros around the edge of the
        # real image.  This is sort of built in if we rotate when there are
        # "real" pixels close to [0,0,0,0] background pixels.
        # 2. It gives straight lines a jagged looks.
        #
        # Perhaps a better version might someday get the best of both worlds by
        # embedding the real image in a larger canvas (filled somehow with the
        # right color -- perhaps by grabbing from the boundary of the real
        # image?), rotating that larger image with INTER_LINEAR (creating an
        # ugly by distant border), and then cropping back to the radius x
        # radius size that we need.

        return rotated_frame

class Align(Enum):
    """ When stacking clips, how should each be placed? """
    CENTER = 1
    LEFT = 2
    TOP = 3
    START = 4
    RIGHT = 5
    BOTTOM = 6
    END = 7

def stack_clips(*args, align, min_dim=0, vert, name):
    """ Arrange a series of clips in a stack, either vertically or
    horizontally.  Probably use vstack or hstack to call this. """

    # Flatten things out, in case the inputs were wrapped in a list.
    clips = flatten_args(args)

    # Compute the width or height.  Do this first so we can maybe center things
    # below.
    dim = min_dim
    for clip in clips:
        if isinstance(clip, Clip):
            clip_dim = clip.width() if vert else clip.height()
            dim = max(dim, clip_dim)
        elif is_int(clip):
            pass
        else:
            raise TypeError(f"In {name}, got a {type(clip)} instead of Clip or int.")

    # Sanity check the alignment.
    if vert:
        valid_aligns = [Align.LEFT, Align.RIGHT, Align.CENTER]
    else:
        valid_aligns = [Align.TOP, Align.BOTTOM, Align.CENTER]

    if align not in valid_aligns:
        raise NotImplementedError(f"Don't know how to align {align} in {name}.")


    # Place each clip in the composite in the correct place.

    a = 0  # The coordinate that we compute each time based on align.
    b = 0  # The coordinate that moves steady forward.

    elements = []

    for clip in clips:
        if isinstance(clip, Clip):
            clip_dim = clip.width() if vert else clip.height()

            if align in [Align.LEFT, Align.TOP]:
                a = 0
            elif align==Align.CENTER:
                a = int((dim - clip_dim)/2)
            else: # align in [Align.RIGHT, Align.BOTTOM]
                a = dim - clip_dim

            elements.append(Element(clip=clip,
                                    start_time=0,
                                    position=[a, b] if vert else [b, a]))

            b += clip.height() if vert else clip.width()
        else: # must be an int, as checked above
            b += clip

    if vert:
        return composite(elements, width=dim, height=b)
    else:
        return composite(elements, height=dim, width=b)

def vstack(*args, align=Align.CENTER, min_width=0):
    """ Arrange a series of clips in a vertical stack. """
    return stack_clips(args, align=align, min_dim=min_width, vert=True, name='vstack')

def hstack(*args, align=Align.CENTER, min_height=0):
    """ Arrange a series of clips in a horizontal row. """
    return stack_clips(args, align=align, min_dim=min_height, vert=False, name='hstack')

def background(clip, bg_color):
    """ Blend a clip onto a same-sized background of the given color. """
    require_clip(clip, 'clip')
    require_color(bg_color, 'background color')

    return composite(Element(solid(bg_color,
                                   clip.width(),
                                   clip.height(),
                                   clip.frame_rate(),
                                   clip.length()),
                             0,
                             (0,0)),
                      Element(clip,
                              0,
                              (0,0),
                              video_mode=VideoMode.BLEND))


def superimpose_center(under_clip, over_clip, start_time, audio_mode=AudioMode.ADD):
    """Superimpose one clip on another, in the center of each frame, starting at
    a given time."""
    require_clip(under_clip, "under clip")
    require_clip(over_clip, "over clip")
    require_float(start_time, "start time")
    require_non_negative(start_time, "start time")

    x = int(under_clip.width()/2) - int(over_clip.width()/2)
    y = int(under_clip.height()/2) - int(over_clip.height()/2)

    return composite(Element(under_clip, 0, [0,0], VideoMode.REPLACE),
                     Element(over_clip, start_time, [x,y], VideoMode.REPLACE, audio_mode))

def loop(clip, length):
    """Repeat a clip as needed to fill the given length."""
    require_clip(clip, "clip")
    require_float(length, "length")
    require_positive(length, "length")

    full_plays = int(length/clip.length())
    partial_play = length - full_plays*clip.length()
    return chain(full_plays*[clip], slice_clip(clip, 0, partial_play))

class ken_burns(MutatorClip):
    """Pan and/or zoom through a clip over time."""
    def __init__(self, clip, width, height, start_top_left, start_bottom_right,
                 end_top_left, end_bottom_right):
        super().__init__(clip)

        # So. Many. Ways to mess up.
        require_int_point(start_top_left, "start top left")
        require_int_point(start_bottom_right, "start bottom right")
        require_int_point(end_top_left, "end top left")
        require_int_point(end_bottom_right, "end bottom right")
        require_non_negative(start_top_left[0], "start top left x")
        require_non_negative(start_top_left[1], "start top left y")
        require_non_negative(end_top_left[0], "end top left x")
        require_non_negative(end_top_left[1], "end top left y")
        require_less(start_top_left[0], start_bottom_right[0],
                     "start top left x", "start bottom right x")
        require_less(start_top_left[1], start_bottom_right[1],
                     "start top left y", "start bottom right y")
        require_less(end_top_left[0], end_bottom_right[0],
                     "end top left x", "end bottom right x")
        require_less(end_top_left[1], end_bottom_right[1],
                     "end top left y", "end bottom right y")
        require_less_equal(start_bottom_right[0], clip.width(),
                           "start bottom right x", "clip width")
        require_less_equal(start_bottom_right[1], clip.height(),
                           "start bottom right y", "clip height")
        require_less_equal(end_bottom_right[0], clip.width(),
                           "end bottom right x", "clip width")
        require_less_equal(end_bottom_right[1], clip.height(),
                           "end bottom right y", "clip height")


        start_ratio = ((start_bottom_right[0] - start_top_left[0])
                       / (start_bottom_right[1] - start_top_left[1]))

        end_ratio = ((end_bottom_right[0] - end_top_left[0])
                     / (end_bottom_right[1] - end_top_left[1]))

        output_ratio = width/height

        if not math.isclose(start_ratio, output_ratio, abs_tol=0.01):
            raise ValueError("This ken_burns effect will distort the image at the start. "
                             f'Starting aspect ratio is {start_ratio}. '
                             f'Output aspect ratio is {output_ratio}. ')

        if not math.isclose(end_ratio, output_ratio, abs_tol=0.01):
            raise ValueError("This ken_burns effect will distort the image at the end. "
                             f'Ending aspect ratio is {end_ratio}. '
                             f'Output aspect ratio is {output_ratio}. ')

        self.start_top_left = np.array(start_top_left)
        self.start_bottom_right = np.array(start_bottom_right)
        self.end_top_left = np.array(end_top_left)
        self.end_bottom_right = np.array(end_bottom_right)

        self.metrics = Metrics(src=clip.metrics,
                               width=width,
                               height=height)

    def get_corners(self, index):
        """ Return the top left and bottom right corners of the view at the
        given frame index. """
        alpha = index/self.clip.num_frames()
        p1 = (((1-alpha)*self.start_top_left + alpha*self.end_top_left))
        p2 = (((1-alpha)*self.start_bottom_right + alpha*self.end_bottom_right))
        p1 = np.around(p1).astype(int)
        p2 = np.around(p2).astype(int)
        return p1, p2

    def frame_signature(self, index):
        p1, p2 = self.get_corners(index)
        return ['ken_burns', {'top_left': p1,
                              'bottom_right': p2,
                              'frame':self.clip.frame_signature(index)}]

    def get_frame(self, index):
        p1, p2 = self.get_corners(index)
        frame = self.clip.get_frame(index)
        fragment = frame[p1[1]:p2[1],p1[0]:p2[0],:]
        sized_fragment = cv2.resize(fragment, (self.width(), self.height()))
        return sized_fragment


def fade_between(clip1, clip2):
    """ Fade from one clip to another.  Both must have the same length. """
    require_clip(clip1, "first clip")
    require_clip(clip2, "second clip")
    require_equal(clip1.length(), clip2.length(), "clip lengths")

    return chain(clip1, clip2, fade_time=clip1.length())

class silence_audio(MutatorClip):
    """ Replace whatever audio we have with silence. """
    def get_samples(self):
        return np.zeros([self.metrics.num_samples(), self.metrics.num_channels])

